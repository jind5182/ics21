HW5


4.47A


void bubble_a(int * data, int count)


{


    int i, last;
    
    
    int * p;
    
    
    for (last = count - 1; last > 0; last--)
    
    
    {
    
    
        for (i =0; p = data; i < last; i++, p++)
	 
	 
	{
	
	
	if (*(p + 1) < *p)
	
	
	    {
	    
	    
	    int t = *(p + 1);
	    
	    
	    *(p + 1) = *p;
	    
	    
	    *p = t;
	    
	    
	    }
	    
	    
	}
	
	
    }
    
    
}
    
   	
    

4.47B


#Ji Weiminghui 1600012736


    .pos    0
    
    
init:


    irmovl stack, %esp
    
    
    irmovl array, %edx		#data
    
    
    pushl %edx
    
    
    irmovl $5, %edx		#count
    
    
    pushl %edx
    
    
    call bubble_a
    
    
    halt
    
    
.align 4


array:


    .long 0x5
    
    
    .long 0x4
  
  
    .long 0x3
    
    
    .long 0x2
    
    
    .long 0x1
    
    
bubble_a:


    #last ecx
    
    
    #i edi
    
    
    #p esi
    
    
    #t 
    
    
    #array 8(%ebp)
    
    
    #count 4(%ebp)
    

    rrmovl %esp, %ebp	
    
    
#for (last = count - 1; last > 0; last--)


    mrmovl 4(%ebp),%eax
    
    
    irmovl $1, %edx
    
    
    subl %edx, %eax		
    
    
    rrmovl %eax, %ecx
    
    
    andl %ecx, %ecx      #ecx=last=count-1
    
    
    jle End


Loop1:


    irmovl $0, %edi	#i=0
    
    
    mrmovl 8(%ebp), %esi#p=data
    
    
    rrmovl %ecx, %eax
    
    
    subl %edi, %eax	#last-i
    
    
    jle Test1
    
    
Loop2:


    mrmovl 4(%esi), %eax # *(p+1)
    
    
    mrmovl (%esi), %edx  # *(p)
    
    
    subl %eax, %edx
    
    
    jle Test2
    
    
    mrmovl (%esi), %edx
    
    
    rmmovl %eax, (%esi)
    
    
    rmmovl %edx, 4(%esi)
    
    
Test2:


    irmovl $1, %edx
    
    
    addl %edx, %edi	#i++
    
    
    irmovl $4, %edx
    
    
    addl %edx, %esi     #p++
    
    
    rrmovl %ecx, %eax
    
    
    subl %edi, %eax     #last-i
    
    
    jg Loop2
    
    
Test1:


    irmovl $1, %edx
    
    
    subl %edx, %ecx	#last--
    
    
    jg Loop1
    
    
End:


    mrmovl 8(%ebp),%eax
    
    
    popl %edx
    
    
    popl %edx
    
    
    ret
    
    
    .pos 0x1300
    
    
stack:



Stopped in 190 steps at PC = 0x1c.  Status 'HLT', CC Z=1 S=0 O=0


Changes to registers:


%eax:	0x00000000	0x0000001c


%edx:	0x00000000	0x00000005


%esp:	0x00000000	0x00001300


%ebp:	0x00000000	0x000012f4


%esi:	0x00000000	0x00000020


%edi:	0x00000000	0x00000001



Changes to memory:


0x001c:	0x00000005	0x00000001


0x0020:	0x00000004	0x00000002


0x0028:	0x00000002	0x00000004


0x002c:	0x00000001	0x00000005


0x12f4:	0x00000000	0x0000001b


0x12f8:	0x00000000	0x00000005


0x12fc:	0x00000000	0x0000001c



4.56


################ Fetch Stage     ###################################


## What address should instruction be fetched at


int f_pc = [

    
    M_icode == IJXX && M_ifun != UNCOND && !M_Cnd && M_valE < M_valA : M_valA;
    
    
    M_icode == IJXX && M_ifun != UNCOND && M_Cnd && M_valE >= M_valA : M_valE;
	
	
	W_icode == IRET : W_valM;
	
	
	1 : F_predPC;
	
	
]; 


# Predict next value of PC


int f_predPC = [
	
	
    f_icode == ICALL: f_valC;
    
    
    f_icode == IJXX && (f_ifun == UNCOND || f_valC < f_valP): f_valC;
    
    
    f_icode == 
    
    
	1 : f_valP;
	
	
];


################ Execute Stage #####################################


## Select input A to ALU


int aluA = [


	E_icode in { IRRMOVL, IOPL } : E_valA;
	
	
	E_icode in { IIRMOVL, IRMMOVL, IMRMOVL } : E_valC;
	
	
	E_icode in { ICALL, IPUSHL } : -4;
	
	
	E_icode in { IRET, IPOPL } : 4;
	
	
        E_icode == IJXX && E_ifun != UNCOND : E_valC;
	
	
];



## Select input B to ALU


int aluB = [


	E_icode in { IRMMOVL, IMRMOVL, IOPL, ICALL, 
	
	
		     IPUSHL, IRET, IPOPL } : E_valB;
		     
		     
	E_icode in { IRRMOVL, IIRMOVL } : 0;
	

        E_icode == IJXX && E_ifun != UNCOND : 0;

];


bool D_bubble =
	
	
    ((E_icode == IJXX && E_ifun != UNCOND && e_Cnd && E_valC >= E_valA) ||
    
    
    (E_icode == IJXX && E_ifun != UNCOND && !e_Cnd && E_valC < E_valA)) ||
    
    
	!(E_icode in { IMRMOVL, IPOPL } && E_dstM in { d_srcA, d_srcB }) &&
	
	
	  IRET in { D_icode, E_icode, M_icode };



# Should I stall or inject a bubble into Pipeline Register E?


# At most one of these can be true.


bool E_stall = 0;


bool E_bubble =


    ((E_icode == IJXX && E_ifun != UNCOND && e_Cnd && E_valC >= E_valA) ||
    
    
    (E_icode == IJXX && E_ifun != UNCOND && !e_Cnd && E_valC < E_valA)) ||
    
    
	E_icode in { IMRMOVL, IPOPL } &&
	
	
	 E_dstM in { d_srcA, d_srcB};



5.13


A.%xmm1 add %xmm1是关键路径


B.3（浮点加法的延迟为3）


C.1（整数加法的延迟为1）


D.需要相乘的元素都不是数据相关的，可以用流水线处理，理论上，每个时钟周期可以发射一个浮点乘法


所以CPA的限制在于具有数据相关性的sum,浮点加法的延迟为3个始终周期，所以，浮点版本的CPE都是3.00



5.14


A.加载两个标量数据需要至少1个时钟周期


B.即使展开成了sum1,sum2,...sum6,对于任意一个sumi，它所执行的浮点数加法，都是一个子关键路径


也就是每个并列执行的sumi都被浮点数加法的延迟所限制，所以展开后的CPA不会小于3


事实上，展开前，只有sum是数据相关的，所以展开前的限制也是浮点数加法


展开只是减少了不必要的循环操作，并没有降低CPA下界


### 第五次作业反馈

第一题：正确  
第二题：正确  
第三题：正确  
第四题：代码呢？？

HW4


3.68


A = 9, B = 5


3.69


A.CNT = 7 


//288-8=280. 280/40=7.


B.typedef struct{ long idx; long x[4]; }a_struct; 或者 typedef struct{ int idx; long x[4]; }a_struct;


//idx:bp+40i+8 x:bp+40i+16 bp代表结构b的起始地址


3.70


A. 0 8 0 8


B.16


C.up->e2.x = *((up->e2.next)->e1.p) - (up->e2.next)->e1.y;


### 第四次作业反馈

第一题：正确  
第二题：有点小问题（idx）  
第三题：正确

HW3

3.60

A.x %rdi,n %esi 和 %ecx, result %rax, mask %rdx

B.result = 0; mask = 1;

C.mask != 0;

D.mask = (mask << n);

E.result |= (x & mask);

F.
long loop(long x,int n)

{

    long result = 0;long mask;
    
    for (mask = 1; mask != 0; mask = (mask << n){
    
   	result |= (x & mask);  	
    }
    
    return result;
   
 }
	

3.62


typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;

long switch3(long * p1, long * p2, mode_t action)

{

    long result = 0;
    
    switch(action){
    
    case MODE_A:
    
   		result = * p2;
   
   		* p2 = * p1;
    
		break;
    
    case MODE_B：
    
   		result = * p1 + * p2;
    	
    		* p1 = result;
    
   		break;
    
    case MODE_C:
    
   		* p1 = 59;
    
   		result = * p2;
    
    		break;
    
     case MODE_D:
    
    		* p1 = * p2;
    
   		result = 27;
    
   		break;
    
    case MODE_E:
    
    		result = 27;
    
    		break;
    
    default:
    
    		result = 12;
 
       		break;
    
    }
    
    return result;
    
}

3.64

A. 对于 T D[R][S][T],  & D[i][j][k] = Xd + L(S * T * i + T * j + k);
  
  L是数据类型T以字节为单位的大小，Xd是数组D的起始位置

B. 由8 * R * S * T = 3640，8 * S * T =520, 8 * T = 104 

   得 R = 7, S = 5, T = 13

### 第三次作业反馈

第一题：正确(括号匹配上有问题)  
第二题：正确  
第三题：正确


2.61
A.	!~x
B.	!x
C.	!((x & 0xFF)^(0xFF))
D.	!(x >> ((sizeof(int) - 1) << 3))

2.62
int int_shifts_are_arithmetic()
{       
        int x = -1;
	return -1 == (x >> 1);
}

2.65
int odd_ones(unsigned x)
{
	x ^= (x >> 16);
	x ^= (x >> 8);
	x ^= (x >> 4);
	x ^= (x >> 2);
	x ^= (x >> 1);
	return x & 1;
 }

### 第一次作业反馈

第一题：正确  
第二题：正确  
第三题：正确  

HW2
2.88
line 1:A 1 01110 001 -9/16 B 1 0110 0010 -9/16
line 2:A 0 10110 101 13*(2^4) B 0 1110 1010 13*(2^4)
line 3:A 1 00111 110 -7/(2^10) B 1 0000 0111 -7/(2^10)
line 4:A 0 00000 101 5/(2^17)   B 0 0000 0001  1/(2^10)
line 5:A 1 11011 000 -2^12       B 1 1110 1111 -31*(2^3)
line 6:A 0 11000 100 3*(2^8) B 0 1111 0000 +∞
2.92 float_bits float_negate(float_bits f) {
if ((f & 0x7F800000) == 0x7F800000);
  return f;
return f ^ 0x80000000;
}
2.96
int float_f2i(float_bits f)// int [-2^31,2^31-1] {
unsigned sign = f >> 31;
unsigned exp = (f >> 23) & 0xFF;
unsigned frac = f & 0x7FFFFF;
unsigned bias = 127;
  int res; unsigned E; unsigned M;
  if (exp >= 31 + bias) // 数太大超范围，或为TMin       res = 0x80000000;
  else if (exp < 0 + bias) // exp>0即使是1.111...除以2也小于1;exp=0显然        res = 0;//下面考虑exp在[bias,30+bias]
  else // >=1且能用int表示   {       E = exp-bias; // E在[0,30]; M = frac | 800000;
       if (E >= 23) // 精确表示         res = M << (E - 23);
else         res = M >> (23 - E); // 向0舍入    }
  return (sign? -res : res); }

### 第二次作业反馈

第一题：正确  
第二题：有误  
第三题：正确  

